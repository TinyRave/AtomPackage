// Generated by CoffeeScript 1.7.1
var AUDIO_BUFFER_SIZE, SAMPLE_RATE, STD_LIBRARY,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

SAMPLE_RATE = 44100;

AUDIO_BUFFER_SIZE = 2048;

STD_LIBRARY = 'importScripts("http://tinyrave.com/lib/v1/adapter.js", "http://tinyrave.com/lib/v1/stdlib.js");';

this.globalAudioContext || (this.globalAudioContext = new (window.AudioContext || window.webkitAudioContext)());

this.audioContextUnlocked = false;

window.addEventListener('touchend', ((function(_this) {
  return function() {
    var buffer, source;
    if (!_this.audioContextUnlocked) {
      buffer = _this.globalAudioContext.createBuffer(1, 1, 22050);
      source = _this.globalAudioContext.createBufferSource();
      source.buffer = buffer;
      source.connect(_this.globalAudioContext.destination);
      source.noteOn(0);
    }
    return _this.audioContextUnlocked = true;
  };
})(this)), false);

this.AudioWorker = (function() {
  function AudioWorker(source) {
    this._workerError = __bind(this._workerError, this);
    this._workerMessage = __bind(this._workerMessage, this);
    var blob;
    blob = new Blob([source]);
    this.worker = new Worker(URL.createObjectURL(blob));
    this.worker.onerror = this._workerError;
    this.worker.onmessage = this._workerMessage;
    if (window.yieldWorker) {
      window.yieldWorker(this.worker);
    }
  }

  AudioWorker.prototype.pop = function() {
    var buffer;
    this.worker.postMessage(["generate"]);
    if (this._buffer != null) {
      buffer = this._buffer;
      this._buffer = null;
      return buffer;
    } else {
      console.log("Dropped an audio frame. If you don't see any other error messages you may be processing too much data. This is normal when system audio is initializing.");
      buffer = new Float64Array(AUDIO_BUFFER_SIZE * 2);
      buffer.fill(0);
      return buffer;
    }
  };

  AudioWorker.prototype.terminate = function() {
    return this.worker.terminate();
  };

  AudioWorker.prototype._workerMessage = function(message) {
    switch (message.data[0]) {
      case "buffer":
        return this._buffer = message.data[1];
      case "log":
        return console.log(message.data[1]);
      default:
        console.log("Worker message received. Arguments:");
        return console.log(message.data);
    }
  };

  AudioWorker.prototype._workerError = function(error) {
    console.log("Worker Error: " + error.message + ". Line " + error.lineno);
    console.log(error);
    return error.preventDefault();
  };

  return AudioWorker;

})();

this.AudioWrapper = (function() {
  function AudioWrapper() {}

  AudioWrapper.prototype.setTrackByURL = function(url) {
    return $.ajax({
      url: url
    }).done((function(_this) {
      return function(data) {
        if (data["source"]) {
          _this.setTrackSource(data["source"], data["duration"]);
        }
        return _this.play();
      };
    })(this));
  };

  AudioWrapper.prototype.setTrackSource = function(compiledSource, duration) {
    if (duration == null) {
      console.error("Must specify duration");
      return;
    }
    duration = parseFloat(duration);
    try {
      this._audioSource.disconnect();
    } catch (_error) {}
    try {
      this._audioAnalyser.disconnect();
    } catch (_error) {}
    this._elapsedTime = 0;
    this._nextCalled = false;
    if (this._worker) {
      this._worker.terminate();
    }
    this._worker = new AudioWorker(STD_LIBRARY + compiledSource);
    this._audioSource = globalAudioContext.createScriptProcessor(AUDIO_BUFFER_SIZE, 0, 2);
    this._audioSource.onaudioprocess = (function(_this) {
      return function(event) {
        var i, left, nextBuffer, right, volume, _i, _ref;
        volume = 0.2;
        left = event.outputBuffer.getChannelData(0);
        right = event.outputBuffer.getChannelData(1);
        nextBuffer = _this._worker.pop();
        for (i = _i = 0, _ref = left.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          left[i] = Math.min(Math.max(volume * nextBuffer[i * 2], -1), 1);
          right[i] = Math.min(Math.max(volume * nextBuffer[i * 2 + 1], -1), 1);
        }
        _this._elapsedTime += AUDIO_BUFFER_SIZE / SAMPLE_RATE;
        if (_this._elapsedTime > duration) {
          return _this.guardedNext();
        }
      };
    })(this);
    return this._audioAnalyser = globalAudioContext.createAnalyser();
  };

  AudioWrapper.prototype.guardedNext = function() {
    if (!this._nextCalled) {
      window.player.next();
    }
    return this._nextCalled = true;
  };

  AudioWrapper.prototype.play = function() {
    if (this._audioSource != null) {
      this._audioSource.connect(this._audioAnalyser);
      this._audioAnalyser.connect(globalAudioContext.destination);
      return this.visualize();
    }
  };

  AudioWrapper.prototype.visualize = function() {
    var BG_COLOR, HEIGHT, LINE_COLOR, WIDTH, bufferLength, canvasCtx, dataArray, draw, el;
    el = document.getElementById('audio_visualizer');
    if (el != null) {
      WIDTH = parseInt(el.getAttribute('width'));
      HEIGHT = parseInt(el.getAttribute('height'));
      BG_COLOR = el.getAttribute('data-bg-color');
      LINE_COLOR = el.getAttribute('data-line-color');
      this._audioAnalyser.fftSize = 2048;
      bufferLength = this._audioAnalyser.fftSize;
      dataArray = new Uint8Array(bufferLength);
      canvasCtx = el.getContext('2d');
      canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
      draw = (function(_this) {
        return function() {
          var drawVisual, i, sliceWidth, v, x, y, _i;
          drawVisual = requestAnimationFrame(draw);
          _this._audioAnalyser.getByteTimeDomainData(dataArray);
          canvasCtx.fillStyle = BG_COLOR;
          canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
          canvasCtx.lineWidth = 1;
          canvasCtx.strokeStyle = LINE_COLOR;
          canvasCtx.beginPath();
          sliceWidth = WIDTH * 1.0 / bufferLength;
          x = 0;
          for (i = _i = 0; 0 <= bufferLength ? _i < bufferLength : _i > bufferLength; i = 0 <= bufferLength ? ++_i : --_i) {
            v = dataArray[i] / 128.0;
            y = v * HEIGHT / 2;
            if (i === 0) {
              canvasCtx.moveTo(x, y);
            } else {
              canvasCtx.lineTo(x, y);
            }
            x += sliceWidth;
          }
          canvasCtx.lineTo(WIDTH, HEIGHT / 2);
          return canvasCtx.stroke();
        };
      })(this);
      return draw();
    }
  };

  AudioWrapper.prototype.pause = function() {
    try {
      return this._audioSource.disconnect();
    } catch (_error) {}
  };

  AudioWrapper.prototype.stop = function() {
    try {
      return this._audioSource.disconnect();
    } catch (_error) {}
  };

  AudioWrapper.prototype.getElapsedTime = function() {
    return this._elapsedTime;
  };

  AudioWrapper.prototype.adjustTime = function(sec) {
    var framesPerSec, i, _i, _ref, _results;
    framesPerSec = 1 / (AUDIO_BUFFER_SIZE / SAMPLE_RATE);
    _results = [];
    for (i = _i = 0, _ref = framesPerSec * sec; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this._worker.pop();
      _results.push(this._elapsedTime += AUDIO_BUFFER_SIZE / SAMPLE_RATE);
    }
    return _results;
  };

  return AudioWrapper;

})();

this.EditorBuilder = (function() {
  function EditorBuilder(editorElement) {
    var editor;
    this.editorElement = editorElement;
    this.keyboard = this.editorElement.data('keyboard');
    this.editor = editor = ace.edit("editor");
    switch (this.keyboard) {
      case 'vim':
        editor.setKeyboardHandler("ace/keyboard/vim");
        break;
      case 'emacs':
        editor.setKeyboardHandler("ace/keyboard/emacs");
    }
    editor.getSession().setUseSoftTabs(true);
    editor.getSession().setTabSize(2);
    editor.$blockScrolling = Infinity;
    editor.focus();
    this._addListeners();
    this._configureCommands();
  }

  EditorBuilder.prototype.setLanguage = function(language) {
    this.language = language;
    this.language.toLowerCase();
    switch (this.language) {
      case 'coffeescript':
        return this.editor.getSession().setMode("ace/mode/coffee");
      case 'javascript':
        return this.editor.getSession().setMode("ace/mode/javascript");
    }
  };

  EditorBuilder.prototype.getLanguage = function() {
    return this.language;
  };

  EditorBuilder.prototype.updateContent = function(data) {
    this.editorElement.removeClass('unloaded');
    this.editor.setValue(data, -1);
    return this.editor.focus();
  };

  EditorBuilder.prototype.getEditor = function() {
    return this.editor;
  };

  EditorBuilder.prototype.getEditorElement = function() {
    return this.editorElement;
  };

  EditorBuilder.prototype._addListeners = function() {
    this.editor.on("blur", (function(_this) {
      return function() {
        return _this.editorElement.addClass('blur');
      };
    })(this));
    return this.editor.on("focus", (function(_this) {
      return function() {
        return _this.editorElement.removeClass('blur');
      };
    })(this));
  };

  EditorBuilder.prototype._configureCommands = function() {
    this.editor.commands.removeCommand("gotoline");
    this.editor.commands.addCommand({
      name: 'Run',
      bindKey: {
        win: 'Ctrl-Enter',
        mac: 'Command-Enter'
      },
      readOnly: true,
      exec: function(editor) {
        return window.playEditorContents();
      }
    });
    return this.editor.commands.addCommand({
      name: 'Stop',
      bindKey: {
        win: 'Ctrl-.',
        mac: 'Command-.'
      },
      readOnly: true,
      exec: function(editor) {
        return window.player.pause();
      }
    });
  };

  return EditorBuilder;

})();
